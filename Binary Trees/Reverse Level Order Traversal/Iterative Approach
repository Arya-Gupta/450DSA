// Time Complexity - 
// Space Complexity - 
// Explanation -

vector<int> reverseLevelOrder(Node *root)
{
    if(!root) return {};
    vector<int> reverseLevelOrderTraversal;
    queue<Node*> Q;
    Q.push(root); // Pushing in the root node initially
        
    // Loop runs until the queue is empty
    while(!Q.empty()){
        int sz = Q.size(); // No of nodes inside the queue
        Node* currNode = Q.front();
        Q.pop(); // Removing node from queue (FIFO)
        if(currNode->right) Q.push(currNode->right); // Insert node to the right of currNode
        if(currNode->left) Q.push(currNode->left); // Insert node to the left of currNode
        reverseLevelOrderTraversal.push_back(currNode->data); // Insert currNode as a part of nodes in the current level
    }
        
    reverse(reverseLevelOrderTraversal.begin(), reverseLevelOrderTraversal.end());  
    return reverseLevelOrderTraversal;
}
